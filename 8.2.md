# C++

## 公有继承和私有继承

1. 通过类继承机制：
可以在已有类的基础上添加功能
可以给新类添加数据属性
可以更改类方法的行为


2. class 派生类名：继承方式  基类名

{
        成员声明；
}

3. 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员

4. 派生类的对象只能访问基类的public成员

5. class 派生类名：继承方式1  基类名1，继承方式2  基类名2，..

{
        成员声明；
}

每一个“继承方式”，只用于限制对紧随其后之基类的继承

6. 派生类的构造函数需要给基类的构造函数传递参数

8. 派生类名::派生类名(基类所需的形参，本类成员所需的形参):基类名(参数表)

{
        本类成员初始化赋值语句；
}；

9. 析构函数也不被继承，派生类自行声明

## 友元
1. 友元提供了不同类之间、非本类成员函数或一般函数使用本类对象非公有成员的一种手段

2. 友元关系是单向的，也是不能传递的

3. 一个类的友元函数是定义在类外部的一个函数，
   它不是类的成员函数，但可访问类的私有成员变量

* 声明在类体内，时在函数的类型说明符前加friend。
定义在类体外，定义格式和普通函数相同。它是非成员函数

## 异常
1. 异常：程序执行时遇到的任何错误情况或意外行为 

2. 异常处理：
	      异常处理就是指当程序出现这些错误后，给与恰当处理，为程序提供退出的安全通道 
3. 确定要保护的代码段、（敏感代码）的工作由try子句来实现



# java

1. **基本类型（int long float ...）的变量在方法中重新赋值后在别的方法中输出值不会改变。但是引用类型重新赋值后会改变。**

2. string类型是引用类型，但用得时候当基本类型使用

3. 静态变量被所有实例共用，成员变量是被实例所私有

4. “==”代表比较双方是否相同，如果是基本类型则表示值相等，如果是引用类型则表示地址是否相等即是同一个对象，

5. “equals”常用引用类型比较。”==“常用基本类型比较

6. super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。

7. this代表本类，super代表父类



##重载，重写

1. 重载在本类中，方法名相同，参数不同

2. 重写是父类和子类方法名相同，但参数不同

3. 多态指的是同一个方法调用，由于对象不同可能会有不同的行为

4. 上转型 Animal a2=new Dog()
* 下转型  Dog dog=(Dog)a2
* 有编译期和运行期（在编译期看声明类型，在运行期看实际类型）
* 向上可以自动转型,向下需要强制类型转换

5. 编写程序时，如果想调用运行时类型的方法，只能进行强制类型转换。否则通不过编译器的检查。

6.  抽象类不能实例化，即不能用new来实例化抽象类

7. 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用

8. 抽象类只能用来被继承。abstract public void shout();  //抽象方法（没有大括号）

## 接口
1. 访问修饰符：只能是public或默认。
2. 接口名：和类名采用相同命名机制。
3. extends：**接口可以多继承**。
4. 常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。
5. 方法：接口中的方法只能是：public abstract
6.  接口不能创建实例，但是可用于声明引用变量类型

